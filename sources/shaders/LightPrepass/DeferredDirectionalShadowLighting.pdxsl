// Copyright (c) 2014 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.
/// <summary>
/// Computes lighting prepass from directional lights with shadows.
/// </summary>
/// <remarks>
/// DEFERRED_MAX_DIRECT_SHADOW_LIGHT_COUNT: Macro - Maximum number of supported directional lights with shadows.
/// </remarks>
#ifndef DEFERRED_MAX_DIRECT_SHADOW_LIGHT_COUNT
# define DEFERRED_MAX_DIRECT_SHADOW_LIGHT_COUNT 1
#endif
class DeferredDirectionalShadowLighting : DeferredLightingBase, ShadowBase
{
    BRDFDiffuseBase brdfDiffuse = stage;
    BRDFSpecularBase brdfSpecular = stage;

    struct DirectLightInfo
    {
        float3 vDirectionVS;
        float intensity;
        float3 color;
    };

    [Link("LightingPrepassRenderer.LightCount")]
    int LightCount = 1;

    cbuffer LightData
    {
        [Link("LightingPrepassRenderer.DirectLightInfos")]
        DirectLightInfo DirectLightInfos[DEFERRED_MAX_DIRECT_SHADOW_LIGHT_COUNT];
    }

    override float4 ComputeLighting(float3 positionVS, float3 normalVS, float3 eyeVS)
    {
        float4 lighting = float4(0,0,0,0);

        ComputeShadowMapPositions(float4(positionVS,1));

#ifdef DEFERRED_DIRECT_LIGHTING_UNROLL_LOOP
        [unroll(DEFERRED_MAX_DIRECT_SHADOW_LIGHT_COUNT)]
#endif
        for (int lightIndex = 0; lightIndex < DEFERRED_MAX_DIRECT_SHADOW_LIGHT_COUNT; ++lightIndex)
        {
#ifndef DEFERRED_DIRECT_LIGHTING_UNROLL_LOOP
            if (lightIndex >= LightCount)
                break;
#endif

            DirectLightInfo lightInfo = DirectLightInfos[lightIndex];
            float3 lightDir = -lightInfo.vDirectionVS;

            // Normalize lightDir
            lightDir = normalize(lightDir);
        
            float3 lightColor = lightInfo.color; // pow(lightInfo.color,2.2);

            // Compute Diffuse Lighting
            float3 diffuseLighting = lightInfo.intensity * brdfDiffuse.ComputeDiffuseLighting(lightColor, lightDir, normalVS, eyeVS);

            // Compute Specular Lighting
            float3 specularLighting = lightInfo.intensity * brdfSpecular.ComputeSpecularLighting(lightColor, lightDir, normalVS, eyeVS);

            float3 shadowFactor = ComputeShadowFactor(lightIndex);

            // To reduce bandwidth we don't store 2 x (RGBDiffuse + RGBSpecular), we store only the RGBDiffuse + Utilities.Luminance(RGBSpecular)
            // Luminance(lighting.Specular)
            lighting += float4(shadowFactor * diffuseLighting, shadowFactor.x * Utilities.Luminance(specularLighting));
        }
        return lighting;
    }
};