// Copyright (c) 2014 Silicon Studio Corp. (http://siliconstudio.co.jp)
// This file is distributed under GPL v3. See LICENSE.md for details.
using System.Collections.Generic;

using SiliconStudio.ActionStack;
using SiliconStudio.Presentation.ViewModel;

namespace SiliconStudio.Presentation.Commands
{
    /// <summary>
    /// A command that supports undo/redo
    /// </summary>
    public abstract class CancellableCommand : CommandBase
    {
        private readonly IViewModelServiceProvider serviceProvider;
        private bool currentlyRunning;

        /// <summary>
        /// Initializes a new instance of the <see cref="CancellableCommand"/> class.
        /// </summary>
        /// <param name="serviceProvider">A service provider that can provide a <see cref="IActionStack"/> to use for this view model.</param>
        /// <param name="dirtiables">The <see cref="IDirtiable"/> instances associated to this command.</param>
        protected CancellableCommand(IViewModelServiceProvider serviceProvider, IEnumerable<IDirtiable> dirtiables)
            : base(serviceProvider)
        {
            this.serviceProvider = serviceProvider;
            Dirtiables = dirtiables;
        }

        /// <summary>
        /// The name of this command.
        /// </summary>
        public abstract string Name { get; }

        protected IEnumerable<IDirtiable> Dirtiables { get; private set; }

        /// <summary>
        /// Choose whether transaction is discarded (true) or ended (false) during <see cref="ExecuteCommand"/>.
        /// </summary>
        protected bool DiscardTransactions { get; set; } = true;

        /// <summary>
        /// Choose whether UndoCommand and ExecuteCommand are reentrant (allowed by default).
        /// </summary>
        protected bool AllowReentrancy { get; set; } = true;

        private IActionStack ActionStack { get { return serviceProvider.Get<IActionStack>(); } }

        /// <inheritdoc/>
        public override void Execute(object parameter)
        {
            ExecuteCommand(parameter, true);
        }

        /// <summary>
        /// Undoes the execution of this command.
        /// </summary>
        /// <param name="parameter">The parameter used to invoke the command.</param>
        /// <param name="token">The <see cref="UndoToken"/> generated by the execution of this command.</param>
        public void UndoCommand(object parameter, UndoToken token)
        {
            if (!AllowReentrancy)
            {
                if (currentlyRunning)
                    return;
                currentlyRunning = true;
            }

            Undo(parameter, token);

            if (!AllowReentrancy)
            {
                currentlyRunning = false;
            }
        }

        /// <summary>
        /// Executes the command and return a token that can be used to undo it.
        /// </summary>
        /// <param name="parameter">The command parameter.</param>
        /// <param name="createActionItem">Indicates whether to create an action item in the action stack. This should be false in case of a Redo operation.</param>
        /// <returns>An <see cref="UndoToken"/> that can be used to undo the command.</returns>
        public UndoToken ExecuteCommand(object parameter, bool createActionItem)
        {
            if (!AllowReentrancy)
            {
                if (currentlyRunning)
                    return new UndoToken(false);
                currentlyRunning = true;
            }

            // TODO: Improve this - we're discarding any change made directly by the command invoke and create a CommandActionItem after.
            // NOTE: PickupAssetCommand is currently assuming that there's such a transaction in progress, be sure to check it if changing this.
            var transactionalActionStack = ActionStack as ITransactionalActionStack;
            if (transactionalActionStack != null)
                transactionalActionStack.BeginTransaction();

            UndoToken token = Redo(parameter, createActionItem);
            
            if (transactionalActionStack != null && DiscardTransactions)
                transactionalActionStack.DiscardTransaction();

            if (token.CanUndo && createActionItem)
            {
                var actionItem = new CommandActionItem(this, parameter, token, Dirtiables);
                ActionStack.Add(actionItem);
            }

            if (transactionalActionStack != null && !DiscardTransactions)
                transactionalActionStack.EndTransaction(Name);

            if (!AllowReentrancy)
            {
                currentlyRunning = false;
            }

            return token;
        }

        /// <summary>
        /// Does or redoes the execution of the command.
        /// </summary>
        /// <param name="parameter">The command parameter.</param>
        /// <param name="creatingActionItem">Indicates whether an action item is being created for the action stack</param>
        /// <returns>An <see cref="UndoToken"/> that can be used to undo the command.</returns>
        protected abstract UndoToken Redo(object parameter, bool creatingActionItem);

        /// <summary>
        /// Undoes the execution of the command.
        /// </summary>
        /// <param name="parameter">The command parameter.</param>
        /// <param name="token">The <see cref="UndoToken"/> generated by the execution of this command.</param>
        protected abstract void Undo(object parameter, UndoToken token);
    }
}